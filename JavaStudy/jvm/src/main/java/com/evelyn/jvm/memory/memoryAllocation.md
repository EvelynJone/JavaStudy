### 加载过程
> 运行MemoryAllocationExample程序时：
- 启动一个Java虚拟机进程，
- 这个进程首先从classpath中找到MemoryAllocationExample.class对象，
- 读取这个文件中的二进制数据，然后把MemoryAllocationExample类的类信息存放到运行时数据区的方法区中
> 这就是MemoryAllocationExample类的加载过程

![image](https://images0.cnblogs.com/i/546270/201404/131631021227107.jpg)

### 运行过程
> 接着，Java虚拟机定位到方法区中MemoryAllocationExample类的main方法的字节码，
开始执行它的指令，这个main方法的第一条语句就是：

```Bean test1 = new Bean("test1")```
##### 该语句的执行过程
- java虚拟机到方法区找到Bean类的类型信息，没有找到，因为Bean类还没有加载到方法区（
这里可以看出，java中的内部类是单独存在的，而且刚开始的时候不会跟随包含类一起被加载，等到要用的时候才被加载）
Java虚拟机立马加载Bean类，把Bean类的类型信息存放在方法区里。
- java虚拟机首先在堆中为一个新的Bean实例分配内存，并在Bean实例的内存中存放一个方法区中存放Bean类的类型信息的内存地址。
- jvm的进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就
被称为栈帧，每当线程调用一个方法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。
- 位于“=”前的Test1是一个在main()方法中定义的一个变量（一个Bean对象的引用），因此，它被会添加到了执行main()方法的主线程的JAVA方法调用栈中。而“=”将把这个test1变量指向堆区中的Bean实例。
- JVM在堆区里继续创建另一个Bean实例，并在main方法的方法调用栈中添加一个Test2变量，该变量指向堆区中刚才创建的Bean新实例
- JVM依次执行它们的printName()方法。当JAVA虚拟机执行test1.printName()方法时，JAVA虚拟机根据局部变量test1持有的引用，定位到堆区中的Sample实例，再根据Sample实例持有的引用，定位到方法去中Sample类的类型信息，从而获得printName()方法的字节码，接着执行printName()方法包含的指令，开始执行。

### 三、辨析

##### 在Java语言里堆(heap)和栈(stack)里的区别 ：
> 1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 

> 2. 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享（详见下面的介绍）。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 

##### Java中的2种数据类型：
> 一种是基本类型(primitive types), 共有8类，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。 
　　
> 栈有一个很重要的特性:存在栈中的数据可以共享。假设我们同时定义:  int a = 3;　　int b = 3;  编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，如果没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 

> 这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 
　　另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。 

### 四、总结
> java内存分配条理还是很清楚的，如果要彻底搞懂，可以去查阅JVM相关的书籍。在java中，内存分配最让人头疼的是String对象，由于其特殊性，所以很多程序员容易搞混淆，下一篇文章再详细讲解